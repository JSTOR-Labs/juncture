<!DOCTYPE html>
<html>
<head>
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" />
  <link href="https://unpkg.com/tippy.js@6/dist/tippy.css" rel="stylesheet"/>
  <link href="https://unpkg.com/tippy.js@6/themes/light-border.css" rel="stylesheet"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
  <title>Juncture</title>
  <style>
    [v-cloak] { display: none; }
    #header, #footer { display: none; }
  </style>
</head>
<body>

  <div id="app" v-cloak ref="app" :class="layouts.join(' ')">
    <div id="header" ref="header">            
      <component v-bind:is="'ve-header'" :active="true" :scroll-top="scrollTop"
                 :site-config="siteConfig"
                 :essay-config="essayConfig"
                 :content-source="contentSource"
                 :path="path"
                 :logins-enabled="loginsEnabled"
                 :is-juncture="isJuncture"
                 :is-authenticated="authenticatedUser !== null && loginsEnabled"
                 :is-admin="isAdminUser"
                 :version="junctureVersion"
                 :do-action-callback="doActionCallback"
                 component-name="ve-header"
                 @do-action="doAction"
                 @authenticate="authenticate"
                 @logout="logout"
      ></component>
    </div>
    <div id="tabs-bar" ref="tabsBar">
      <span v-for="viewer in viewersEnabled" :key="`tab-${viewer}`" 
            :class="{'active-tab': selectedViewer === viewer}" 
            :data-tab="viewer" 
            @click="selectedViewer = viewer; viewerIsOpen = true">
        <i v-if="viewerData[viewer]" :class="viewerData[viewer].icon"></i>
      </span>
    </div>
    <div id="essay" ref="essay" @scroll="onScroll">
      <component v-bind:is="mainComponent"
        :html="html"
        :path="path"
        :anchor="anchor"
        :entities="entities"
        :params="params"
        :available-viewers="availableViewers"
        :scroll-top="scrollTop"
        :content-source="contentSource"
        @set-entities="entities = $event"
        @set-params="params = $event"
        @set-items="items = $event"
        @set-active="active = $event"
        @scroll-to-anchor="scrollToAnchor"
        @load-essay="loadEssay"
        @do-action="doAction"
      ></component>
    </div>

    <div v-if="essayConfig" id="viewer" ref="viewer" :style="viewerStyle">
      <i v-if="!isVerticalLayout && viewerIsOpen" class="far fa-times-circle" style="position:absolute; top:0; right:0; z-index:500; font-size:26px;" @click="viewerIsOpen = !viewerIsOpen"></i>
      <component v-for="viewer in viewersEnabled" :key="viewer" v-bind:is="viewer" 
                 :items="items"
                 :entities="entities"
                 :viewer-is-active="viewer === selectedViewer"
                 :active-segment="active"
                 :height="viewerHeight"
                 :actions="actions"
                 :hover-item="hoverItem"
                 :content-source="contentSource"
                 :gh-token:="ghToken"
                 :md-dir="mdDir"
                 :is-authenticated="authenticatedUser !== null && loginsEnabled"
                 :component-name="viewer"
                 @update-component-data="updateComponentData"
                 @set-hover-item="hoverItem = $event"
      ></component>
    </div>
    <div v-if="essayConfig && path === '/'" id="footer" ref="footer">            
      <component v-bind:is="'ve-footer'" :site-config="siteConfig" :content-source="contentSource"></component>
    </div>

    <div ref="markdownViewer" id="markdown-viewer" style="display: none;">
      <div style="padding:20px; width:50vw; height:50vh; overflow-y:scroll;">
        <h3>Markdown</h3>
        <div>
          <pre v-highlightjs="markdown"><code class="markdown"></code></pre>
        </div>
      </div>
    </div>

    <div id="create-site-form" class="modal-form" style="display: none;">
      <form v-on:submit.prevent>
        <h1>Create new Juncture site</h1>
        <input :value="authenticatedUser && authenticatedUser.acct" class="form-name" type="text" readonly>
        <input v-model="newRepo" placeholder="Repository name to update or create" class="form-email" required>
        <div v-html="formProcessingMessage"></div>
        <div class="form-controls">
          <button v-if="formProcessingStatus === 'ready'" class="form-cancel" formnovalidate @click="hideForm">Cancel</button>
          <button v-if="formProcessingStatus === 'ready'" class="form-submit" @click="doSiteCreate">Create site</button>
          <button v-if="formProcessingStatus === 'done'" class="form-submit" @click="loadNewSite">Close</button>
        </div>
      </form>
    </div>

    <div id="add-page-form" class="modal-form" style="display: none;">
      <form v-on:submit.prevent>
        <h1>Add new page</h1>
        <input :value="authenticatedUser && authenticatedUser.acct" class="form-name" type="text" readonly>
        <input v-if="contentSource.acct !== 'jstor-labs' && contentSource.repo !== 'juncture'" :value="contentSource.repo" class="form-name" type="text" readonly>
        <select v-else v-model="selectedRepo" class="form-name">
          <option v-for="repo in reposForAcct" :key="repo.name" :value="repo.name" v-text="repo.name"></option>
        </select>
        <input v-model="newPage" placeholder="Name of new page" class="form-email" required>
        <div v-html="formProcessingMessage"></div>
        <div class="form-controls">
          <button v-if="formProcessingStatus === 'ready'" class="form-cancel" formnovalidate @click="hideForm">Cancel</button>
          <button v-if="formProcessingStatus === 'ready'" class="form-submit" @click="doPageAdd">Add page</button>
          <button v-if="formProcessingStatus === 'done'" class="form-submit" @click="gotoAddedPage">Close</button>
        </div>
      </form>
    </div>

    <div id="update-site-form" class="modal-form" style="display: none;">
      <form v-on:submit.prevent>
        <h1>Update Juncture site</h1>
        <input :value="contentSource.acct" class="form-name" type="text" readonly>
        <input :value="contentSource.repo" class="form-name" type="text" readonly>
        <div style="display:float; padding:6px 0"><span>Version:</span>
          <select v-model="selectedRelease">
            <option v-for="release in releases" :key="release.name" :value="release" selected v-text="release.name"></option>
          </select>
        </div>
        <div v-html="formProcessingMessage"></div>
        <div class="form-controls">
          <button v-if="formProcessingStatus === 'ready'" class="form-cancel" formnovalidate @click="hideForm">Cancel</button>
          <button v-if="formProcessingStatus === 'ready'" class="form-submit" @click="doSiteUpdate">Update site</button>
          <button v-if="formProcessingStatus === 'done'" class="form-submit" @click="hideForm">Close</button>
        </div>
      </form>
    </div>

  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it-footnote/3.0.2/markdown-it-footnote.min.js" integrity="sha512-9VOGZLBYkfqGR+OigfgoF3RUvDJRvQ9BAVgOKYmrvXlX7k+yBm5iJCpZEMpqmg2b1Cld1fiy2p0nEbDAcz9Q4w==" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/markdown-it-attrs@4.0.0/markdown-it-attrs.browser.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/12.0.6/markdown-it.min.js" integrity="sha512-7U8vY7c6UQpBNQOnBg3xKX502NAckvk70H1nWvh6W7izA489jEz+RCN3ntT1VMdXewaSKkOrEBegp/h6SPXrjw==" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/http-vue-loader@1.4.2/src/httpVueLoader.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/yamljs/0.3.0/yaml.min.js" integrity="sha512-f/K0Q5lZ1SrdNdjc2BO2I5kTx8E5Uw1EU3PhSUB9fYPohap5rPWEmQRCjtpDxNmQB4/+MMI/Cf+nvh1VSiwrTA==" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@popperjs/core@2"></script>
  <script src="https://unpkg.com/tippy.js@6"></script>
  <script src="https://blueimp.github.io/JavaScript-MD5/js/md5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.4.3/firebase.js"></script>
  
  <!-- This is used for deep linking of Single Page Apps when hosted with GitHub Pages -->
  <script type="text/javascript">
    (function(l) {
      if (l.search) {
        let q = {}
        l.search.slice(1).split('&').forEach(function(v) {
          let a = v.split('=')
          q[a[0]] = a.slice(1).join('=').replace(/~and~/g, '&')
        })
        if (q.p !== undefined) {
          window.history.replaceState(null, null, l.pathname.slice(0, -1) + (q.p || '') + (q.q ? ('?' + q.q) : '') + l.hash)
        }
      }
    }(window.location))
  </script>
  
  <script>
  
    console.log(window.location)
    const ENV = window.location.hostname === 'localhost' || window.location.hostname.indexOf('gitpod') > 0 ? 'DEV' : 'PROD'
    const isJuncture = window.location.hostname.indexOf('juncture-digital.org') >= 0 || window.location.host === 'localhost:8088'
    const junctureVersion = 'v0.2.5'
    let junctureVersionHash

    const referrerUrl = document.referrer
    if (referrerUrl) {
      const referrer = parseUrl(referrerUrl)
      if (referrer.host === 'github.com') {
        const referrerPath = referrer.pathname.slice(1).split('/')
        const ghAcct = referrerPath[0]
        const ghRepo = referrerPath[1]
        const ghBranch = referrerPath.length > 3 ? referrerPath[3] : 'main'
        const pathStart = 4
        const pathEnd = referrerPath[referrerPath.length-1] === 'README.md' || referrerPath[referrerPath.length-1] === 'index.md' ? referrerPath.length-1 : referrerPath.length
        const ghPath = referrerPath.slice(pathStart, pathEnd).join('/').replace(/\.md$/, '')
        const redirect = `${window.location.origin}/${ghAcct}/${ghRepo}/${ghPath}${ghBranch === 'master' || ghBranch === 'main' ? '' : '?ref=' + ghBranch}`
        window.location = redirect
      }
    }
    
    Vue.directive('highlightjs', {
      deep: true,
      bind: function(el, binding) {
        let targets = el.querySelectorAll('code')
        targets.forEach((target) => {
          if (binding.value) {
            target.textContent = binding.value
          }
          hljs.highlightBlock(target)
        })
      },
      componentUpdated: function(el, binding) {
        let targets = el.querySelectorAll('code')
        targets.forEach((target) => {
          if (binding.value) {
            target.textContent = binding.value
            hljs.highlightBlock(target)
          }
        })
      }
    })

    let md = window.markdownit({
      html:         true,
      breaks:       false,
      linkify:      false,
      typographer:  false,
      highlight: function (str, lang) {
        if (lang && hljs.getLanguage(lang)) {
          try {
            return hljs.highlight(lang, str).value;
        } catch (__) {}
      }
      return ''; // use external default escaping
      }
    })
    .use(window.markdownitFootnote)
    .use(markdownItAttrs)

    async function getContentSource() {
      let contentSource

      if (window.location.host === 'localhost:8088') {
        // For local dev in custom domain mode
        contentSource = {
          acct: null, repo: null, branch: null, ref: null, hash: null, basePath: '', isGhpSite: false,
          baseUrl: window.location.origin, 
          assetsBaseUrl: `${window.location.origin}`
      }
        let pathElems = window.location.pathname.split('/').filter(elem => elem !== '')
        if (pathElems.length >= 2) {
          let ghRepoInfo = await githubRepoInfo(pathElems[0], pathElems[1])
          if (ghRepoInfo) {
            contentSource = {...contentSource, ...ghRepoInfo}
          }
        }

      } else if (ENV === 'DEV') {
        // For local dev in GHP mode
        let repo = window.location.pathname.split('/').filter(elem => elem !== '')[0] || 'juncture'
        contentSource = {acct: 'jstor-labs', repo, branch: 'main', ref: 'main', hash: null, baseUrl: window.location.origin, basePath: `/${repo}`, isGhpSite: true,
                         assetsBaseUrl: `${window.location.origin}/${repo}`}

      } else {
        // GHP deploy mode
        if (window.location.hostname.indexOf('github.io') > 0) {
          [acct, repo] = window.location.href.replace(/\.github\.io/,'').split('/').slice(2, 4)
          contentSource = {
            acct, repo, ref: qargs.ref || 'main', basePath: `/${repo}`, isGhpSite: true,
            baseUrl: window.location.origin
          }
          let ghRepoInfo = await githubRepoInfo(acct, repo)
          if (ghRepoInfo) {
            contentSource = {...contentSource, ...ghRepoInfo}
          }

        // juncture-digital.org
        } else if (isJuncture) {
          contentSource = {
            acct: 'jstor-labs', repo: 'juncture', ref: 'main', basePath: '', isGhpSite: false,
            baseUrl: window.location.origin, assetsBaseUrl: `https://raw.githubusercontent.com/jstor-labs/juncture/main`
          }
          let pathElems = window.location.pathname.split('/').filter(elem => elem !== '')
          if (pathElems.length >= 2) {
            let ghRepoInfo = await githubRepoInfo(pathElems[0], pathElems[1])
            if (ghRepoInfo) {
              contentSource = {...contentSource, ...ghRepoInfo}
              contentSource.basePath = `/${contentSource.acct}/${contentSource.repo}`
            }
          }

        // Deployed in a non juncture-digital.org custom domain
        } else {
          contentSource = {acct: null, repo: null, ref: null, baseUrl: window.location.origin, basePath: '', isGhpSite: false}
        }
      }
      return contentSource
    }

    let qargs = window.location.href.indexOf('?') > 0 ? parseQueryString(window.location.href.split('?')[1]) : {}
    
    // GLobal variables used to initialize Vue
    let siteConfig, contentSource, componentsList, ghUnscopedToken, oauthAccessToken, gcApiKey, gcAuthDomain, gaPropertyID, fontawesome
    let loginsEnabled = false
    let authenticatedUser = null
    
    const componentsRoot = 'components'
    const componentPrefix = 've-'
    const availableViewers = []
    const knownGhAccts = {'jstor-labs': 'main', 'kent-map': 'main'}

    async function headRef(acct, repo, ref, token) {  
      token = token || oauthAccessToken || ghUnscopedToken
      let heads, tags, found, sha
      console.log(`headRef: acct=${acct} repo=${repo} ref=${ref} token=${token} oauthAccessToken=${oauthAccessToken} ghUnscopedToken=${ghUnscopedToken}`)
      let resp = await fetch(`https://api.github.com/repos/${acct}/${repo}/git/refs/heads`, {
        headers: {Authorization: `Token ${token}`, Accept: 'application/vnd.github.v3+json'} })
      if (resp.ok) {
        heads = await resp.json()
        found = heads.find(head => head.ref === `refs/heads/${ref}`)
        sha = found ? found.object.sha : null
      } 
      if (!sha) {
        resp = await fetch(`https://api.github.com/repos/${acct}/${repo}/tags`)
        if (resp.ok) {
          tags = await resp.json()
          found = tags.find(tag => tag.name === ref)
          sha = found ? found.commit.sha : null
        }
      }
      return sha
    }

    async function getFile(acct, repo, ref, path, token) {
      token = token || oauthAccessToken || ghUnscopedToken
      console.log(`getFile: token=${token} oauthAccessToken=${oauthAccessToken} ghUnscopedToken=${ghUnscopedToken}`)
      console.log(`getFile: acct=${acct} repo=${repo} ref=${ref} path=${path} token=${token}`)
      let content
      let resp = await fetch(`https://api.github.com/repos/${acct}/${repo}/contents${path}?ref=${ref}`, {headers: {Authorization:`Token ${token}`}})
      if (resp.ok) {
        resp = await resp.json()
        content = decodeURIComponent(escape(atob(resp.content)))
      }
      return Promise.resolve(content)
    }

    async function gcOauth() {
      if (gcApiKey && gcAuthDomain) {
        firebase.initializeApp({apiKey: gcApiKey, authDomain: gcAuthDomain})
        let result = await firebase.auth().getRedirectResult()
        if (result.credential) window.localStorage.setItem('ghAuth', JSON.stringify(result))
      }
      try {
        let ghAuth = JSON.parse(window.localStorage.getItem('ghAuth'))
        if (ghAuth) {
          authenticatedUser = ghAuth.user
          authenticatedUser.acct = ghAuth.additionalUserInfo.username
          authenticatedUser.isAdmin = siteConfig.siteAdmins && siteConfig.siteAdmins.indexOf(authenticatedUser.acct) >= 0
          oauthAccessToken = ghAuth.credential.oauthAccessToken
        }
      } catch(err){console.log(err)}
    }

    getContentSource()
    .then(sourceInfo => {
      contentSource = sourceInfo
      return getSiteConfig()
    })
    .then(config => {
      siteConfig = config
      //if (ENV === 'PROD') {
        contentSource = {...contentSource, ...{
            acct: config.acct || contentSource.acct, 
            repo: config.repo || contentSource.repo, 
            ref: qargs.ref || config.ref || contentSource.ref
        }}
      //}
    
      if (gaPropertyID) ga('create', gaPropertyID, 'auto')
      let attrsWithUrls = ['banner', 'favicon']

      if (ENV === 'PROD' || window.location.port === '8088') {
        headRef(contentSource.acct, contentSource.repo, contentSource.ref).then(headHash => {
          if (headHash) {
            contentSource.hash = headHash.slice(0,7)
            contentSource.assetsBaseUrl = `https://raw.githubusercontent.com/${contentSource.acct}/${contentSource.repo}/${contentSource.hash}`
            attrsWithUrls.forEach(attr => { if (config[attr]) config[attr] = convertURL(config[attr]) })
          }
        })
      } else {
        attrsWithUrls.forEach(attr => { if (config[attr]) config[attr] = convertURL(config[attr]) })
      }
      return config
    })
    .then(config => gcOauth())
    .then(resp => headRef('jstor-labs', 'juncture', junctureVersion, ghUnscopedToken))
    .then(hash => {
      junctureVersionHash = hash.slice(0,7)
      console.log(`isJuncture=${isJuncture} junctureVersion=${junctureVersion} junctureVersionHash=${junctureVersionHash} referrer=${document.referrer}`)
      return getComponentsList()
    })
    .then(clist => {
      componentsList = clist
      componentsList.forEach(componentUrl => {
        let httpComponent = httpVueLoader(componentUrl)
        let componentName = `${componentPrefix}${camelToKebab(componentUrl.split('/').pop().split('.')[0])}`
        if (availableViewers.indexOf(componentName) <0) {
          availableViewers.push(componentName)
          Vue.component(componentName, httpComponent)
        }
      })

      if (siteConfig.favicon ) document.querySelector('head').appendChild(makeLink(siteConfig.favicon, 'icon'))
      if (siteConfig.title) document.title = siteConfig.title
      if (fontawesome) document.querySelector('body').appendChild(makeScriptTag(fontawesome, 'anonymous'))
      

      let mainCssPromise = ENV === 'DEV'
        ? fetch(`${window.location.port === '8088' ? '' : '/juncture'}/css/main.css`).then(resp => resp.text())
        : getFile('jstor-labs', 'juncture', junctureVersionHash, '/css/main.css')
      mainCssPromise.then(css => {
      let style = document.createElement('style')
        style.innerHTML = css
        document.querySelector('head').appendChild(style)
      })

      let customCssPromise = ENV === 'DEV'
        ? fetch(`${contentSource.assetsBaseUrl}/css/custom.css`).then(resp => resp.text())
        : getFile(contentSource.acct, contentSource.repo, contentSource.ref, '/css/custom.css')
      customCssPromise.then(css => {
        if (css) {
          let style = document.createElement('style')
          style.innerHTML = css
          document.querySelector('head').appendChild(style)
        }
      })

      new Vue({
        el: '#app',
        data: () => ({
          html: null,
          entities: {},
          params: [],
          anchor: null,
          items: [],
          active: null,

          qargs,
          layouts: [],
          siteConfig,
          contentSource,
          componentsList,
          isJuncture,
          junctureVersion,
          path: '/',
          mdpath: '',
          mdDir: '/',
          markdown: null,
          markdownViewer: null,
          viewerHeight: 0,
          availableViewers,
          selectedViewer: null,
          viewerData: {},
          scrollTop: 0,
          forceHorizontalLayout: window.matchMedia('only screen and (max-width: 1000px)').matches,
          viewerIsOpen: false,
          hoverEntity: undefined,
          hoverItem: undefined,
          selectedItem: undefined,
          actions: {},
          authenticatedUser,
          loginsEnabled,
          externalWindow: null,
          newRepo: null,
          newPage: null,
          formProcessingMessage: '',
          formProcessingStatus: 'ready',
          releases: [],
          selectedRelease: null,
          reposForAcct: [],
          selectedRepo: null,
          doActionCallback: {},
          essayConfig: null
        }),
        computed: {
          // essayConfig() { return this.params.find(attr => attr['ve-config'] !== undefined) },
          mainComponent() { return this.essayConfig && this.essayConfig.component ? `ve-${this.essayConfig.component.toLowerCase()}` : null},
          isAdminUser() { return authenticatedUser !== null && (authenticatedUser.isAdmin || contentSource.acct === authenticatedUser.acct) },
          ghToken() { return oauthAccessToken || ghUnscopedToken },
          viewerStyle() { return { 
            height: this.viewerIsOpen
              ? this.isVerticalLayout 
                ? '100%'
                : `calc(50vh - ${this.$refs.header.clientHeight/2}px)`
              : 0 
            } 
          },
          isVerticalLayout() { return !this.forceHorizontalLayout && this.layouts.indexOf('vertical') >= 0 },
          viewersEnabled() { 
            let viewers = this.items.filter(item => this.availableViewers.indexOf(item.viewer) >= 0).map(item => item.viewer)
            return viewers.filter((viewer, index) => viewers.indexOf(viewer) === index)
          }
        },
        mounted() {
          this.anchor = window.location.href.indexOf('#') >= 0 ? window.location.href.split('#').pop() : null
          window.onpopstate = (e) => this.loadEssay(e.state.file, true) 
          const resizeObserver = new ResizeObserver(entries => { 
            this.forceHorizontalLayout = window.matchMedia('only screen and (max-width: 1000px)').matches
          })
          resizeObserver.observe(this.$refs.app)
          this.loadEssay()
          // Initialize Markdown source viewer
          this.markdownViewer = tippy(this.$refs.header, {
            trigger: 'manual', 
            theme: 'light-border',
            allowHTML: true,
            interactive: true,
            arrow: false,
            placement: 'bottom-start',          
            onShow: async (instance) => { instance.setContent(this.$refs.markdownViewer.innerHTML) },
            onHide: (instance) => {}
          })
        },
        methods: {

          authenticate() {
            let provider = new firebase.auth.GithubAuthProvider()
            provider.addScope('repo')
            firebase.auth().signInWithRedirect(provider)
          },
          logout() { this.authenticatedUser = null; window.localStorage.removeItem('ghAuth') },

          editMarkdown() {
            this.openWindow(`https://github.com/${this.contentSource.acct}/${this.contentSource.repo}/edit/${this.contentSource.ref}${this.mdPath}`) 
          },
          openWindow(url, options) {
            if (this.externalWindow) { this.externalWindow.close() }
            if (options === undefined) options = 'toolbar=yes,location=yes,left=0,top=0,width=1000,height=1200,scrollbars=yes,status=yes'
            this.externalWindow = window.open(url, '_blank', options)
          },

          // Updates viewer data from events emitted when viewer components are loaded
          updateComponentData(data) { this.viewerData = {...this.viewerData, ...data }},

          // Sets active element based on essay window scroll position
          onScroll: _.throttle(function (e) {
            e.preventDefault()
            e.stopPropagation()
            this.scrollTop = e.target.scrollTop
          }, 5),

          // Handles menu actions from header
          async doAction(action, options) {
            console.log('doAction', action, options)
            if (action === 'send-email') {
              this.doActionCallback = {status: 'processing', message: 'Processing request'}
              await sendEmail(options)
              this.doActionCallback = {status: 'done', message: 'Email sent'}
            } else if (action === 'viewMarkdown') {
              this.markdownViewer.show()
            } else if (action === 'editMarkdown') {
              this.editMarkdown()
            } else if (action === 'addPage') {
              this.reposForAcct = await this.listRepositories()
              this.selectedRepo = this.reposForAcct.length > 0 ? this.reposForAcct[0].name : null
              this.showForm('add-page-form')
            } else if (action === 'createSite') {
              this.showForm('create-site-form')
            } else if (action === 'updateSite') {
              let releases = await getGHReleases()
              this.selectedRelease = releases[0]
              this.releases = releases
              this.showForm('update-site-form')
            } else if (action === 'gotoGitHub') {
              window.open(`https://github.com/${contentSource.acct}/${contentSource.repo}/tree/${contentSource.ref}`, '_blank')
            } else if (action === 'viewSiteOnJuncture') {
              window.location.href = `https://juncture-digital.org/${contentSource.acct}/${contentSource.repo}`
            } else if (action === 'authenticate') {
              this.authenticate()
            } else if (action === 'logout') {
              this.logout()
            } else if (action === 'loadEssay') {
              this.loadEssay(options)
            }
          },

          showForm(formId) {
            this.$refs.app.classList.add('dimmed')
            let form = document.getElementById(formId)
            form.style.display = 'unset'
            form.classList.add('visible-form')
          },

          hideForm() {
            this.$refs.app.classList.remove('dimmed')
            let form = document.querySelector('.visible-form')
            form.style.display = 'none'
            form.classList.remove('visible-form')
            this.formProcessingMessage = ''
            this.formProcessingStatus = 'ready'
          },

          async doSiteCreate() {
            this.formProcessingStatus = 'processing'
            this.formProcessingMessage = 'Creating site...'
            await this.createSite(this.authenticatedUser.acct, this.newRepo, junctureVersion)
            let siteUrl = `https://${this.authenticatedUser.acct}.github.io/${this.newRepo}`
            this.formProcessingMessage = `New Juncture site created at <a href="${siteUrl}">${siteUrl}</a>`
            this.formProcessingStatus = 'done'
          },
          
          loadNewSite() {
            this.hideForm()
            // window.location.href = `https://juncture-digital.org/${this.authenticatedUser.acct}/${this.newRepo}`
            window.open(`https://juncture-digital.org/${this.authenticatedUser.acct}/${this.newRepo}`, '_blank')
          },

          gotoAddedPage() {
            this.hideForm()
            this.loadEssay(this.newPage)
          },

          async doSiteUpdate() {
            this.formProcessingStatus = 'processing'
            this.formProcessingMessage = `Updating site to version ${this.selectedRelease.name}...`
            await this.updateSite(this.selectedRelease)
            let siteUrl = `https://${this.contentSource.acct}.github.io/${this.contentSource.repo}`
            this.formProcessingMessage = `Site <a href="${siteUrl}">${siteUrl}</a> updated to version ${this.selectedRelease.name}`
            this.formProcessingStatus = 'done'
          },

          async doPageAdd() {
            let targetRepo = this.reposForAcct.find(repo => repo.name === this.selectedRepo)
            if (targetRepo) {
              if (this.newPage[0] !== '/') this.newPage = `/${this.newPage}`
              if (this.newPage[this.newPage.length-1] === '/') this.newPage = this.newPage.slice(0,-1)
              this.formProcessingStatus = 'processing'
              this.formProcessingMessage = `Adding essay ${this.newPage} to ${targetRepo.name}...`             
              await this.addPage(this.authenticatedUser.acct, targetRepo.name, targetRepo.default_branch, this.newPage)
              this.contentSource.acct = this.authenticatedUser.acct
              this.contentSource.repo = targetRepo.name
              this.contentSource.ref = targetRepo.default_branch
              this.contentSource.basePath = `/${this.authenticatedUser.acct}/${targetRepo.name}`
              let refHash = await headRef(this.contentSource.acct, this.contentSource.repo, this.contentSource.ref)
              contentSource.assetsBaseUrl = `https://raw.githubusercontent.com/${this.contentSource.acct}/${this.contentSource.repo}/${refHash}`
              this.formProcessingMessage = `New page added`
              this.formProcessingStatus = 'done'
            }
          },

          gotoSite(url) { 
            this.hideForm()
            window.open(url, '_blank') 
          },

          async getMarkdown(path) {
            if ((ENV === 'PROD' || window.location.port === '8088') && contentSource.acct) {
              let url = `https://api.github.com/repos/${contentSource.acct}/${contentSource.repo}/contents${path}?ref=${contentSource.ref}`
              let resp = await fetch(url, this.ghToken ? {cache: 'no-cache', headers: {Authorization:`Token ${this.ghToken}`}} : {})
              if (resp.ok) {
                resp = await resp.json()
                return decodeURIComponent(escape(atob(resp.content)))
              }
            } else {
              let url = `${contentSource.baseUrl}${contentSource.basePath}${path}`
              let resp = await fetch(url)
              if (resp.ok) return await resp.text()
            }
            return null
          },

          // Loads essay Markdown file
          async loadEssay(path, replace, anchor) {
            // Array.from(this.$refs.app.classList).forEach(cls => this.$refs.app.classList.remove(cls))
            this.essayConfig = null
            path = path || window.location.pathname.slice(contentSource.basePath.length) || '/'
            if (path.slice(-1) !== '/') path += '/'
            this.path = path 
            console.log(`loadEssay: basePath=${contentSource.basePath} path=${path} anchor=${this.anchor}`)
            let pathsToTry = [`${path}README.md`, `${path.slice(0,-1)}.md`, `${path}index.md`]
            let markdown
            for (let i = 0; i < pathsToTry.length; i++) {
              markdown = await this.getMarkdown(pathsToTry[i])
              if (markdown) {
                this.mdDir = i === 1 ? '/' : path
                break
              }
              this.mdPath = pathsToTry[i]
            }
            if (markdown) {
              ([this.markdown, this.html, this.params, this.entities] = await this.parseMarkdown(markdown))
              let essayConfig = this.params.find(param => param['ve-config']) || {}
              if (essayConfig.banner) essayConfig.banner = convertURL(essayConfig.banner)
              essayConfig.component = essayConfig.component || 'essay'
              this.essayConfig = essayConfig
            }
            if (gaPropertyID) ga('send', 'pageview', `${contentSource.basePath}${path}`)

            let browserPath = `${contentSource.basePath}${path}${this.anchor ? '#'+this.anchor : ''}`
            if (qargs.ref) browserPath += `?ref=${qargs.ref}`
            if (replace) {
              history.replaceState({file: path || ''}, '', browserPath)
            } else {
              history.pushState({file: path || ''}, '', browserPath)
            }

          },

          // Convert essay Markdown into HTML.  Markdown headings are used to infer content heirarchy
          async parseMarkdown(markdown) {
            let tmp = new DOMParser().parseFromString(md.render(markdown), 'text/html').children[0].children[1]
            this.convertResourceUrls(tmp)
      
            let essay = document.createElement('div')
            let currentSection = essay
            let segments = []
            let segment

            tmp.querySelectorAll('param').forEach(param => {
              if (param.id || param.classList.length > 0) {
                let prior = param.previousElementSibling
                if (param.id) {
                  prior.id = param.id
                  param.removeAttribute('id')
                }
                if (param.classList.length > 0) prior.classList.add(param.classList)
                param.parentElement.removeChild(param)
              }
            })

            Array.from(tmp.children).forEach(el => {
              if (el.tagName[0] === 'H' && isNumeric(el.tagName.slice(1))) {
                let sectionLevel = parseInt(el.tagName.slice(1))
                if (segments) {
                  segments.forEach(segment => currentSection.innerHTML += segment.outerHTML)
                  segments = []
                  segment = null
                }
                currentSection = new DOMParser().parseFromString('<section></section>', 'text/html').children[0].children[1].children[0]
                let elClasses = Array.from(el.classList)
                el.removeAttribute('class')
                if (el.id) {
                  currentSection.id = el.id
                  el.removeAttribute('id')
                }
                if (!el.innerHTML) el.style.display = 'none'
                currentSection.innerHTML += el.outerHTML

                let headings = [...essay.querySelectorAll(`H${sectionLevel-1}`)]
                let parent = sectionLevel === 1 || headings.length === 0 ? essay : headings.pop().parentElement
                let parentDataID = parent.dataset.id || ''
                let sectionSeq = parent.querySelectorAll(`H${sectionLevel}`).length + 1
                let currentDataID = parentDataID ? `${parentDataID}.${sectionSeq}` : sectionSeq
                currentSection.setAttribute('data-id', currentDataID)

                if (elClasses.indexOf('cards') >= 0) {
                  let wrapper = new DOMParser().parseFromString('<section class="cards"></section>', 'text/html').children[0].children[1].children[0]
                  currentSection.appendChild(wrapper)
                } else {
                  currentSection.classList.add(...elClasses)
                  let wrapper = parent.querySelector(':scope > .cards')
                  if (wrapper) {
                    currentSection.classList.add('card')
                    parent = wrapper
                  }
                }

                parent.appendChild(currentSection)

              } else if (el.tagName === 'P') {
                if (el.innerHTML.indexOf('ve-button.png') >= 0) {
                  el = null
                } else if (el.innerHTML.indexOf('class="nav"') >= 0) {
                  currentSection.innerHTML += el.innerHTML
                } else {
                  let segID = `${currentSection.dataset.id}.${segments.length + 1}`
                  segment = new DOMParser().parseFromString('<div></div>', 'text/html').children[0].children[1].children[0]
                  segment.setAttribute('data-id', segID)
                  segment.setAttribute('id', segID)
                  segment.classList.add('segment')
                  segment.innerHTML = el.outerHTML
                  segments.push(segment)

                  /*
                  let segLink = document.createElement('span')
                  segment.appendChild(segLink)
                  segLink.outerHTML = `<span class="seg-link" data-anchor="${this.contentSource.baseUrl}${this.contentSource.basePath}${this.path}#${segID}" title="${segID}"><i class="fas fa-link"></span>`
                  */
                }
              } else if (el.tagName === 'SECTION' && el.className === 'footnotes') {
                currentSection.innerHTML += el.outerHTML
              } else {
                if (segment) {
                  segment.innerHTML += el.outerHTML
                } else {
                  currentSection.innerHTML += el.outerHTML
                }
              }
            })
            if (segments) {
              segments.forEach(segment => currentSection.innerHTML += segment.outerHTML)
              segments = []
            }

            let assignedId = 0
            let params = Array.from(essay.querySelectorAll('param'))
              .map(paramEl => {
                let prior = paramEl.previousElementSibling
                while (prior && prior.tagName !== 'P' && prior.tagName[0] !== 'H') {
                  prior = prior.previousElementSibling
                }
                return { ...{ path: getDomPath(prior || tmp).join('>') }, ...attrsToObject(paramEl) }
              })
              .map(paramObj => {
                let viewerTag = Object.keys(paramObj).find(attr => !attr.value && this.availableViewers.indexOf(attr) >= 0)
                if (viewerTag) paramObj.viewer = viewerTag
                else if (!Object.keys(paramObj).find(attr => attr.indexOf('ve-') === 0)) paramObj['ve-entity'] = ''
                return paramObj
              })
              .map(paramObj => {
                if (!paramObj.id) paramObj.id = paramObj.eid || `P${++assignedId}`
                return paramObj
              })

              let entities = await this.getEntityData(this.findEntities(tmp, params))

            return [markdown, essay.innerHTML, params, entities]
          },

          // Finds all entity references in param tags
          findEntities(root, params) {

            let entities = Object.fromEntries(
              params.filter(param => param.eid || param['ve-entity'] !== undefined)
              .map(entity => { return {...entity, ...{
                id: entity.eid || entity.id, 
                aliases: new Set(entity.aliases ? entity.aliases.split('|') : []),
                foundIn: new Set()
              }} })
              .map(entity => [entity.id, entity]))
            
            Array.from(root.querySelectorAll('span'))
              .filter(el => el.attributes.eid)
              .map(el => attrsToObject(el))
              .map(entity => { return {...entity, ...{id: entity.eid || entity.id} } })
              .forEach(entity => { if (!entities[entity.eid]) entities[entity.eid] = entity })

            params.filter(param => param.center && isEntityID(param.center))
              .map(param => { return {...param, ...{id: param.center, eid: param.center} } })
              .forEach(entity => { if (!entities[entity.eid]) entities[entity.eid] = entity })

            return entities
          },

          // Gets labels, aliases, images and geo coords for referenced Wikdata entities
          async getEntityData(entities) {
            let values = Object.values(entities).filter(entity => entity.eid).map(entity => `(<http://www.wikidata.org/entity/${entity.eid}>)`).join(' ')
            let query = `SELECT ?item ?label ?aliases ?description ?images ?coords ?whosOnFirst WHERE {
                            VALUES (?item) { ${values} }
                            ?item rdfs:label ?label . FILTER(LANG(?label) = 'en')
                            OPTIONAL { ?item schema:description ?description . FILTER(LANG(?description) = 'en') }
                            OPTIONAL { ?item skos:altLabel ?aliases . FILTER(LANG(?aliases) = 'en') }
                            OPTIONAL { ?item wdt:P18 ?images . }
                            OPTIONAL { ?item wdt:P625 ?coords . }
                            OPTIONAL { ?item wdt:P6766 ?whosOnFirst . }
                          }`
            let resp = await fetch('https://query.wikidata.org/sparql', {
              method: 'POST', body: `query=${encodeURIComponent(query)}`, 
              headers: { Accept: 'application/sparql-results+json', 'Content-Type': 'application/x-www-form-urlencoded' }
            })
            resp = await resp.json()
            // let enrichedEntities = {}
            resp.results.bindings.forEach(rec => {
              let eid = rec.item.value.split('/').pop()
              if (!entities[eid].images) entities[eid] = {
                  ...entities[eid], 
                  ...{
                    eid, 
                    label: rec.label.value, 
                    aliases: new Set(entities[eid].aliases ? Array.from(entities[eid].aliases) : []),
                    description: rec.description && rec.description.value,
                    geojson: rec.whosOnFirst && rec.whosOnFirst.value && this.whosOnFirstUrl(rec.whosOnFirst.value),
                    images: [],
                    thumbnails: [],
                    coords: rec.coords && rec.coords.value.replace(/Point\(/,'').replace(/\)/,'').split(' ').reverse().map(coord => parseFloat(coord)),
                    foundIn: new Set(),
                  }
                }
              if (rec.aliases && !entities[eid].aliases.has(rec.aliases.value)) entities[eid].aliases.add(rec.aliases.value)
              if (rec.images && entities[eid].images.indexOf(rec.images.value) < 0) {
                entities[eid].images.push(rec.images.value)
                entities[eid].thumbnails.push(this.commonsImageUrl(rec.images.value, 200))
              }
            })
            query = `SELECT ?item ?mwPage WHERE {
                        VALUES (?item) { ${values} }
                        ?mwPage schema:about ?item .
                        ?mwPage schema:isPartOf <https://en.wikipedia.org/> . }`
            resp = await fetch('https://query.wikidata.org/sparql', {
              method: 'POST', body: `query=${encodeURIComponent(query)}`, 
              headers: { Accept: 'application/sparql-results+json', 'Content-Type': 'application/x-www-form-urlencoded' }
            })
            resp = await resp.json()
            resp.results.bindings.forEach(rec => entities[rec.item.value.split('/').pop()]['mwPage'] = rec.mwPage.value)
            return entities
          },

          convertResourceUrls(root) {
            root.querySelectorAll('img').forEach(img => {
              if (img.src.indexOf(window.location.origin) === 0) img.setAttribute('src', convertURL(img.src))
            })
            root.querySelectorAll('param').forEach(param => {
              ['url', 'banner', 'article'].forEach(attr => {
                if (param.attributes[attr]) param.setAttribute(attr, convertURL(param.attributes[attr].value, `${contentSource.basePath}${this.path}`, this.mdDir !== '/'))
              })
            })
            return root
          },

          // Creates a GeoJSON file URL from a Who's on First ID 
          whosOnFirstUrl(wof) {
            let wofParts = []
            for (let i = 0; i < wof.length; i += 3) {
              wofParts.push(wof.slice(i,i+3))
            }
            return `https://data.whosonfirst.org/${wofParts.join('/')}/${wof}.geojson`
          },

          commonsImageUrl(url, width) {
            // Converts Wikimedia commons File URL to an image link
            //  If a width is provided a thumbnail is returned
            let mwImg = url.indexOf('Special:FilePath') > 0 ? url.split('/Special:FilePath/').pop() :  url.split('/File:').pop()
            mwImg = decodeURIComponent(mwImg).replace(/ /g,'_')
            const ImgMD5 = md5(mwImg)
            const extension = mwImg.slice(mwImg.length-4)
            let imgUrl = `https://upload.wikimedia.org/wikipedia/commons/${width ? 'thumb/' : ''}`
            imgUrl += `${ImgMD5.slice(0,1)}/${ImgMD5.slice(0,2)}/${mwImg}`
            if (width) imgUrl += `/${width}px-${mwImg}`
            if (extension === '.svg') imgUrl += '.png'
            if (extension === '.tif') imgUrl += '.jpg'
            return imgUrl
          },

          scrollToAnchor() {
            let anchorElem = document.getElementById(this.anchor)
            if (anchorElem) this.scrollTop = anchorElem.offsetTop
            this.anchor = null
          },

          addItemEventHandlers(elem) {
            elem.querySelectorAll('.inferred').forEach((entity) => {
              entity.addEventListener('click', this.itemClickHandler)
              entity.addEventListener('mouseover', this.setHoverItem)
              entity.addEventListener('mouseout', this.setHoverItem)
            })
          },
          removeItemEventHandlers(elem) {
            elem.querySelectorAll('.active .inferred').forEach((entity) => {
              entity.removeEventListener('click', this.itemClickHandler)
              entity.removeEventListener('mouseover', this.setHoverItem)
              entity.removeEventListener('mouseout', this.setHoverItem)
            })
          },

          setHoverItem(e) {
            this.hoverItem = e.type === 'mouseover' ? e.target.dataset.eid : null
          },
          itemClickHandler(e) {
            e.stopPropagation()
            this.selectedItem = e.target.dataset.eid 
          },

          getInteractionAttrs(elem) {
            const eventAttrs = []
            Array.from(elem.querySelectorAll(`span`)).forEach(span => {
              Array.from(span.attributes)
                .filter(attr => attr.name.indexOf('data-') === 0 && attr.name.split('-').length === 4)
                .map(attr => attr.name.split('-').slice(1,2)[0])
                .forEach(event => eventAttrs.push({elem: span, event}))
              })
            return eventAttrs
          },

          addInteractionHandlers(elem) {
            this.getInteractionAttrs(elem)
            .forEach(eventAttr => {
              eventAttr.elem.addEventListener(eventAttr.event, this.interactionHander)
              eventAttr.elem.classList.add('essay-interaction')
            })
          },
  
          removeInteractionHandlers(elem) {
            Array.from(elem.querySelectorAll('.essay-interaction')).forEach(span => {
              Array.from(span.attributes)
                .filter(attr => attr.name.indexOf('data-') === 0 && attr.name.split('-').length === 4)
                .map(attr => attr.name.split('-').slice(1,2)[0])
                .forEach(event => span.removeEventListener(event, this.interactionHander))
              span.classList.remove('essay-interaction')
            })
          },

          interactionHander(e) {
            e.stopPropagation()
            const eventActions = {}
            Array.from(e.target.attributes)
              .filter(attr => attr.name.indexOf(`data-`) === 0 && attr.name.split('-').length === 4)
              .map(attr => {
                const attrParts = attr.name.split('-').slice(1)
                const event = attrParts[0]
                const target = attrParts.slice(1,-1).join('-')
                const action = attrParts.slice(-1)[0]
                return { elem: e.target, event, target, action, value: attr.value } 
              })
              .filter(action => action.event === e.type)
              .forEach(action => {
                if (!eventActions[action.target]) eventActions[action.target] = []
                eventActions[action.target].push(action)
              })
            const actions = { ...this.actions }
            Object.keys(eventActions).forEach(target => actions[`ve-${target}`] = eventActions[target])
            this.actions = actions
          },

          replaceValues(content, replacements) {
            for (const [toMatch, replacementValue] of Object.entries(replacements)) { content = content.replace(new RegExp(toMatch, 'g'), replacementValue) }
            return content
          },

          async copyFile (src, tgt, path) {
            let existing
            resp = await fetch(`https://api.github.com/repos/${tgt.acct}/${tgt.repo}/contents${src.path}?ref=${tgt.ref}`, {headers: {Authorization: `Token ${this.ghToken}`}})
            if (resp.ok) existing = await resp.json()
            resp = await fetch(`https://api.github.com/repos/${src.acct}/${src.repo}/contents${src.path}?ref=${src.ref}`, {headers: {Authorization: `Token ${this.ghToken}`}})
            resp = await resp.json()
            let file = decodeURIComponent(escape(atob(resp.content)))
            let payload = { message: 'initial', branch: tgt.ref, content: btoa(file) }
            if (existing) payload.sha = existing.sha
            resp = await fetch(`https://api.github.com/repos/${tgt.acct}/${tgt.repo}/contents${tgt.path || src.path}?ref=${tgt.ref}`, {
              method: 'PUT', body: JSON.stringify(payload), headers: {Authorization: `Token ${this.ghToken}`} })
          },

          async waitForRepoInit(acct, repo, i) {
            i = i === undefined ? 0 : i
            let resp = await fetch(`https://api.github.com/repos/${acct}/${repo}/git/refs/heads`, {
                  headers: {Authorization:`Token ${this.ghToken}`, Accept: 'application/vnd.github.v3+json'} })
            let heads = resp.ok ? await resp.json() : null
            if (heads === null && i < 2) setTimeout(this.waitForRepoInit(acct, repo, ++i), 500)
            return heads
          },

          async syncFiles(targetAcct, targetRepo, fromRef, isCreate) {
            // Create a juncture branch in repo if needed
            let resp
            let heads = await this.waitForRepoInit(targetAcct, targetRepo)
            if (heads) {
              let mainHead = heads.find(head => head.ref === 'refs/heads/main')
              let ghpHead = heads.find(head => head.ref === 'refs/heads/juncture')
              if (!ghpHead) {
                resp = await fetch(`https://api.github.com/repos/${targetAcct}/${targetRepo}/git/refs`, {
                    method: 'POST', body: JSON.stringify({ref: 'refs/heads/juncture', sha: mainHead.object.sha}),
                    headers: {Authorization:`Token ${this.ghToken}`, Accept: 'application/vnd.github.v3+json'} })

                // Make target repository a GitHub Pages site
                resp = await fetch(`https://api.github.com/repos/${targetAcct}/${targetRepo}/pages`, {
                  headers: {Authorization:`Token ${this.ghToken}`, Accept: 'application/vnd.github.switcheroo-preview+json'} })
                if (resp.status === 404) {
                  resp = await fetch(`https://api.github.com/repos/${targetAcct}/${targetRepo}/pages`, {
                    method: 'POST', body: JSON.stringify({source: {branch: 'juncture', path: '/'}}),
                    headers: {Authorization:`Token ${this.ghToken}`, Accept: 'application/vnd.github.switcheroo-preview+json'} })
                }
              }
            }

            // template tages used for customized starter pages
            let replacementValues = {
              '<<acct>>': targetAcct,
              '<<repo>>': targetRepo,
              '<<display-name>>': authenticatedUser.displayName,
              '<<email>>': authenticatedUser.email,
              }

            // At this point we have a juncture branch and it is configured as the Github Pages source
            resp = await this.getFile('/index.html', 'jstor-labs', 'juncture', fromRef)
            await this.putFile('/index.html', resp.content.replace(/const junctureVersion = '.*'/, `const junctureVersion = '${fromRef}'`), targetAcct, targetRepo, 'juncture')

            await this.copyFile({acct:'jstor-labs', repo:'juncture', ref: fromRef, path:'/404.html'}, {acct: targetAcct, repo: targetRepo, ref:'juncture'})
            await this.copyFile({acct:'jstor-labs', repo:'juncture', ref: fromRef, path:'/.nojekyll'}, {acct: targetAcct, repo: targetRepo, ref:'juncture'})

            if (targetAcct === 'jstor-labs' && targetRepo === 'juncture') {
              await this.copyFile({acct:'jstor-labs', repo:'juncture', ref: fromRef, path: '/css/main.css'}, {acct: targetAcct, repo: targetRepo, ref:'juncture'})
            }

            if (isCreate) {
              resp = await this.getFile('/config.yaml', 'jstor-labs', 'juncture', fromRef)
              await this.putFile('/config.yaml', this.replaceValues(resp.content, replacementValues), targetAcct, targetRepo, 'juncture')

              resp = await this.getFile('/page-templates/new-site-readme.md', 'jstor-labs', 'juncture', fromRef)
              let toReplace = {...replacementValues, ...{'<<edit-url>>': `https://github.com/${targetAcct}/${targetRepo}/edit/main/README.md`}}
              await this.putFile('/README.md', this.replaceValues(resp.content, toReplace), targetAcct, targetRepo, 'main')

              await this.addPage(targetAcct, targetRepo, fromRef, '/about')
            }

          },

          async listRepositories() {
            let resp = await fetch(`https://api.github.com/users/${authenticatedUser.acct}/repos?per_page=100&sort=created`, { headers: {Authorization: `Token ${this.ghToken}`}} )
            return resp.ok ? await resp.json() : []
          },

          async addPage(acct, repo, ref, path) {
            console.log(`addPage: acct=${acct} repo=${repo} ref=${ref} path=${path}`)
            let replacementValues = {'<<acct>>': acct, '<<repo>>': repo, '<<display-name>>': authenticatedUser.displayName, '<<email>>': authenticatedUser.email}
            resp = await this.getFile('/page-templates/new-page-readme.md', 'jstor-labs', 'juncture', 'main')
            toReplace = {...replacementValues, ...{'<<edit-url>>': `https://github.com/${acct}/${repo}/edit/${ref}${path}/README.md`}}
            await this.putFile(`${path}/README.md`, this.replaceValues(resp.content, toReplace), acct, repo, ref)
          },

          async createSite(targetAcct, targetRepo, fromRef) {
            console.log(`createSite: targetAcct=${targetAcct} targetRepo=${targetRepo} fromRef=${fromRef}`)
            // See if repo exists and create it if needed
            let resp = await fetch(`https://api.github.com/repos/${targetAcct}/${targetRepo}`, { headers: {Authorization: `Token ${this.ghToken}`}} )
            let repoExists = resp.ok
            if (repoExists) {
              let resp = await fetch(`https://api.github.com/repos/${targetAcct}/${targetRepo}/contents/index.html?ref=juncture`, {headers: {Authorization:`Token ${this.ghToken}`}})
              if (resp.ok) sha = await resp.json().sha
            } else { // create repo with auto_init enabled to create main branch and README.md file
              resp = await fetch('https://api.github.com/user/repos', { method: 'POST', headers: {Authorization:`Token ${this.ghToken}`},
                  body: JSON.stringify({name: targetRepo, description: 'Juncture repository', auto_init: true}) })
              resp = await resp.json()
            }

            this.syncFiles(targetAcct, targetRepo, fromRef, true)

            // Request rebuild of Pages site
            await fetch(`https://api.github.com/repos/${targetAcct}/${targetRepo}/pages/builds`, {method: 'POST', headers: {Authorization: `Token ${this.ghToken}`}})
          },

          async updateSite(release) {
            console.log(`updateSite: release=${release.name} tag=${release.tag_name}`)
            this.syncFiles(contentSource.acct, contentSource.repo, release.tag_name, false)
          }
    
        },

        watch: {

          scrollTop: {
            handler: function (scrollTop) { 
              this.viewerHeight = this.$refs.viewer.clientHeight
            },
            immediate: false
          },

          // Set app classes using essay config (ve-config) attributes, if present
          essayConfig (config) {
            this.layouts = []
            this.viewerIsOpen = false
            if (config) {
              if (config.layout) this.layouts = config.layout.split(',').map(layout => layout === 'vtl' ? 'vertical' : layout)
              // Array.from(this.$refs.app.classList).forEach(cls => this.$refs.app.classList.remove(cls))
              if (config.class) config.class.replace(/,/,' ').split(' ').forEach(cls => this.$refs.app.classList.add(cls))
            }
          },

          // Watcher that updates various data elements when the active paragraph changes
          active(current, prior) {
            let activeSegment = document.querySelector(`[data-id="${current}"]`)
            if (activeSegment) {
              if (this.$refs.tabsBar) activeSegment.appendChild(this.$refs.tabsBar)
              this.addItemEventHandlers(activeSegment)
              this.addInteractionHandlers(activeSegment)
            }
            let priorSegment = document.querySelector(`[data-id="${prior}"]`)
            if (priorSegment) {
              this.removeItemEventHandlers(priorSegment)
              this.removeInteractionHandlers(priorSegment)
            }
          },

          viewersEnabled: {
            handler: function () {
              this.selectedViewer = this.viewerIsOpen && this.viewersEnabled.length > 0 ? this.viewersEnabled[0] : null
            },
            immediate: true
          },

          isVerticalLayout: {
            handler: function () {
              this.selectedViewer = this.isVerticalLayout && this.viewersEnabled.length > 0 ? this.viewersEnabled[0] : this.selectedViewer
              if (this.isVerticalLayout) this.viewerIsOpen = true
            },
            immediate: true
          },

          // logging watchers
          params (params) {
            console.log('params', params)
            // Load custom components declared in page markdown
            params
              .filter(param => param['ve-component'] !== undefined)
              .map(param => param.url)
              .forEach(customComponentUrl => {
                let httpComponent = httpVueLoader(customComponentUrl)
                let componentName = `${componentPrefix}${camelToKebab(customComponentUrl.split('/').pop().split('.')[0])}`
                if (availableViewers.indexOf(componentName) < 0) {
                  availableViewers.push(componentName)
                  Vue.component(componentName, httpComponent)
                }
            })
          },
          entities (entities) { console.log('entities', entities) },
          selectedViewer (selectedViewer) { console.log('selectedViewer', selectedViewer) },
          selectedItem (eid) { console.log(`selectedItem=${eid}`) },
          hoverItem (eid) {
            document.querySelectorAll('.hover').forEach(el => el.classList.remove('hover'))
            document.querySelectorAll(`[data-eid="${eid}"]`).forEach(el => el.classList.add('hover'))        
          }
        }
      })
    })

    Vue.config.productionTip = false
    Vue.config.devtools = true

    // Vue components mixin that handles linking to external JS and CSS resources
    Vue.mixin({
      props: {
        componentName: String
      },
      methods: {
        loadDependencies(dependencies, i, callback) {
          if (i === 0) {
            let componentData = {}
            componentData[this.componentName] = { label: this.viewerLabel, icon: this.viewerIcon }
            this.$emit('update-component-data', componentData)
          }
          if (dependencies && dependencies.length > 0) {
            this.load(dependencies[i], () => {
              if (i < dependencies.length-1) {
                this.loadDependencies(dependencies, i+1, callback) 
              } else {
                callback()
              }
            })
          } else {
            if (callback) callback()
          }
        },
        load(url, callback) {
          let e
          if (url.split('.').pop() === 'js') {
            e = document.createElement('script')
            e.src = url
            e.type='text/javascript'
          } else {
            e = document.createElement('link')
            e.href = url
            e.rel='stylesheet'
          }
          e.addEventListener('load', callback)
          document.getElementsByTagName('head')[0].appendChild(e)
        },
        delimitedStringToObjArray(delimitedData, delimiter) {
          delimiter = delimiter || `\t`
          const objArray = []
          const lines = delimitedData.split('\n').filter(line => line.trim() !== '')
          if (lines.length > 1) {
            const keys = lines[0].split(delimiter).map(key => key.trim())
            lines.slice(1).forEach(line => {
              let obj = {}
              line.split(delimiter)
                  .map(value => value.trim())
                  .forEach((value, i) => {
                    let rawKey = keys[i].split('.')
                    let key = rawKey[0]
                    let prop = rawKey.length === 2 ? rawKey[1] : 'id'
                    if (!obj[key]) obj[key] = {}
                    if (value || prop === 'id') obj[key][prop] = value
                  })
              objArray.push(obj)
            })
            let assignedId = 0
            let labels = {}
            objArray.forEach(obj => {
              Object.values(obj).forEach(child => {
                if (child.id === '' && child.label) {
                  if (!labels[child.label]) labels[child.label] = ++assignedId
                  child.id = labels[child.label]
                }
              })
            })
          }
          return objArray
        },
        async getFile(path, acct, repo, ref) {
          acct = acct || this.contentSource.acct
          repo = repo || this.contentSource.repo
          ref = ref || this.contentSource.ref
          let ghToken = oauthAccessToken || ghUnscopedToken
          console.log(`getFile: path=${path} acct=${acct} repo=${repo} ref=${ref} ghToken=${ghToken}`)
          if (ENV === 'PROD' && acct) {
            let url = `https://api.github.com/repos/${acct}/${repo}/contents${path}?ref=${ref}`
            let resp = await fetch(url, ghToken ? {headers: {Authorization:`Token ${ghToken}`}} : {})
            if (resp.ok) {
              resp = await resp.json()
              return { sha: resp.sha, content: decodeURIComponent(escape(atob(resp.content))) }
            }
          } else {
            let url = `${this.contentSource.baseUrl}${this.contentSource.basePath}${path}`
            let resp = await fetch(url)
            if (resp.ok) resp = await resp.text()
            return {content: resp}
          }
          return null
        },
        async putFile(path, content, acct, repo, branch, message) {
          acct = acct || this.contentSource.acct
          repo = repo || this.contentSource.repo
          branch = branch || this.contentSource.ref
          message = message || 'API Commit'
          console.log(`putFile: path=${path} acct=${acct} repo=${repo} branch=${branch} message=${message}`)
          if (ENV === 'PROD' && acct) {
            let ghToken = oauthAccessToken || ghUnscopedToken
            let existing = await this.getFile(path, acct, repo, branch)
            let payload = { message, branch, content: btoa(content) }
            if (existing) payload.sha = existing.sha
            let url = `https://api.github.com/repos/${acct}/${repo}/contents${path}?ref=${branch}`
            let resp = await fetch(url, { method: 'PUT', body: JSON.stringify(payload), headers: {Authorization: `Token ${ghToken}`} })
            resp = await resp.json()
          } else {
            let url = `${this.contentSource.baseUrl}${this.contentSource.basePath}${path}`
            let resp = await fetch(url, { method: 'PUT', body: content })
          }
        }
      }
    })

    // Various utility and helper methods
    function camelToKebab(input) { return input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()}
    function kebabToCamel(input) { return input.replace(/-([a-z])/g, function (g) {return g[1].toUpperCase()})}
    function isNumeric(arg) { return !isNaN(arg) }
    function isEntityID(arg) { return typeof arg === 'string' && arg.split(':').slice(-1).find(val => val.length > 1 && val[0] === 'Q' && isNumeric(val.slice(1))) !== undefined }
    function attrsToObject(el) { return Object.fromEntries(Array.from(el.attributes).map(attr => 
                      [attr.nodeName, attr.value === '' || attr.value === 'true' ? true : attr.value === 'false' ? false : attr.value] )) }
    function getDomPath(el) {
      var stack = []
      while ( el.parentNode != null ) {
        let sibCount = 0
        let sibIndex = 0
        for ( var i = 0; i < el.parentNode.childNodes.length; i++ ) {
          let sib = el.parentNode.childNodes[i];
          if ( sib.nodeName == el.nodeName ) {
            if ( sib === el ) {
              sibIndex = sibCount;
            }
            sibCount++
          }
        }
        if ( el.hasAttribute('id') && el.id != '' ) {
          stack.unshift(el.nodeName.toLowerCase() + `#${el.id}`)
        } else if ( sibCount > 1 ) {
          stack.unshift(el.nodeName.toLowerCase() + (sibIndex > 0 ? `[${sibIndex}]` : ''))
        } else {
          stack.unshift(el.nodeName.toLowerCase())
        }
        el = el.parentNode
      }
      return stack.slice(1) // removes the html element
    }

    // Gets site config
    async function getSiteConfig() {
      let config = {}
      let junctureConfigUrl = isJuncture && window.location.host !== 'localhost:8088' 
        ? `${window.location.origin}/config.yaml`
        : 'https://raw.githubusercontent.com/jstor-labs/juncture/juncture/config.yaml'
      let resp = await fetch(junctureConfigUrl)
      resp = YAML.parse(await resp.text())
      ghUnscopedToken = atob(resp.ghUnscopedToken)
      fontawesome = resp.fontawesome
      if (isJuncture) {
        config = resp
        gcApiKey = atob(config.gcApiKey)
        gcAuthDomain = atob(config.gcAuthDomain)
        gaPropertyID = config.gaPropertyID
      }
      if (contentSource.isGhpSite) {
        resp = await fetch(`${contentSource.baseUrl}${contentSource.basePath}/config.yaml`)
        if (resp.ok) config = YAML.parse(await resp.text())
      } else if (contentSource.acct && (contentSource.repo !== 'juncture' || contentSource.acct !== 'jstor-labs')) {
        config = {}
        let ghToken = oauthAccessToken || ghUnscopedToken
        resp = await fetch(`https://api.github.com/repos/${contentSource.acct}/${contentSource.repo}/contents/config.yaml?ref=juncture`,
                               ghToken ? {headers: {Authorization:`Token ${ghToken}`}} : {})
        if (resp.ok) {
          resp = await resp.json()
          config = YAML.parse(atob(resp.content))
        }
      } else if (!isJuncture) {
        resp = await fetch(`${window.location.origin}/config.yaml`)
        if (resp.ok) config = YAML.parse(await resp.text())
      }
      if (config.ghUnscopedToken) ghUnscopedToken = atob(config.ghUnscopedToken)
      if (config.gcApiKey) gcApiKey = atob(config.gcApiKey)
      if (config.gcAuthDomain) gcAuthDomain = atob(config.gcAuthDomain)
      if (config.gaPropertyID) gaPropertyID = config.gaPropertyID
      if (config.fontawesome) fontawesome = config.fontawesome
      loginsEnabled = gcApiKey !== undefined && gcAuthDomain !== undefined
      return config
    }

    async function getGHTags() {
      let resp = await fetch('https://api.github.com/repos/jstor-labs/juncture/tags')
      resp = await resp.json()
      return resp.map(tag => tag.name)
    }

    async function getGHReleases() {
      let resp = await fetch('https://api.github.com/repos/jstor-labs/juncture/releases')
      return await resp.json()
    }

    // Determines if Github repo exists
    async function githubRepoInfo(acct, repo) {
      let ghInfo
      //if (knownGhAccts[acct]) {
      //  ghInfo = {acct, repo, ref: qargs.ref || knownGhAccts[acct], basePath: `/${acct}/${repo}`}
      //} else {
        let ghToken = oauthAccessToken || ghUnscopedToken
        let resp = await fetch(`https://api.github.com/repos/${acct}/${repo}`,
                               ghToken ? { headers: {Authorization: `Token ${ghToken}`}} : {} )
        if (resp.ok) {
          resp = await resp.json()
          ghInfo = {acct, repo, branch: resp.default_branch, ref: qargs.ref || resp.default_branch}
        }
      //}
      if (ghInfo) {
        // let refHash = await headRef(ghInfo.acct, ghInfo.repo, ghInfo.ref)
        // ghInfo.assetsBaseUrl = `https://raw.githubusercontent.com/${ghInfo.acct}/${ghInfo.repo}/${refHash}`
      }
      return ghInfo

    }
  
    // Gets a list of available components
    async function getComponentsList() {
      let ref = contentSource.acct === 'jstor-labs' && contentSource.repo === 'juncture' ? junctureVersionHash : contentSource.ref
      // console.log(`getComponentsList: ref=${ref} junctureVersionHash=${junctureVersionHash}`)
      let componentsList = []
      let ghToken = ENV === 'DEV' ? ghUnscopedToken : (oauthAccessToken || ghUnscopedToken)
      if (ENV === 'PROD' && contentSource.acct && contentSource.repo && contentSource.ref) {
        let resp = await fetch(`https://api.github.com/repos/${contentSource.acct}/${contentSource.repo}/git/trees/${ref}`,
                               ghToken ? { headers: {Authorization: `Token ${ghToken}`}} : {} )
        if (resp.ok) {
          resp = await resp.json()
          let ghComponentsItem = resp.tree.find(item => item.path === componentsRoot)
          if (ghComponentsItem) {
            resp = await fetch(ghComponentsItem.url, ghToken ? { headers: {Authorization: `Token ${ghToken}`}} : {} )
            resp = await resp.json()
            componentsList = [...componentsList, ...resp.tree.map(item => `https://raw.githubusercontent.com/${contentSource.acct}/${contentSource.repo}/${ref}/${componentsRoot}/${item.path}`)]
          }
        }
      } 
      if (ENV === 'DEV') {
        let basePath = contentSource.isGhpSite ? contentSource.basePath : ''
        let resp = await fetch(`${contentSource.baseUrl}${basePath}/${componentsRoot}`)
        resp = await resp.json()
        componentsList = [...componentsList, ...resp.files.map(fname => `${contentSource.baseUrl}${basePath}/${componentsRoot}/${fname}`)]
      }
      // if (isJuncture && contentSource.acct !== 'jstor-labs' || contentSource.repo !== 'juncture') {
      if (contentSource.repo !== 'juncture' || contentSource.acct !== 'jstor-labs') {
        if (ENV === 'DEV') {
          let basePath = contentSource.isGhpSite ? '/juncture' : ''
          let resp = await fetch(`${contentSource.baseUrl}${basePath}/${componentsRoot}`)
          resp = await resp.json()
          componentsList = [...componentsList, ...resp.files.map(fname => `${contentSource.baseUrl}${basePath}/${componentsRoot}/${fname}`)]
        } else {
          let resp = await fetch(`https://api.github.com/repos/jstor-labs/juncture/git/trees/${junctureVersionHash}`, ghToken ? {headers: {Authorization: `Token ${ghToken}`}} : {})
          resp = await resp.json()
          resp = await fetch(resp.tree.find(item => item.path === componentsRoot).url, ghToken ? {headers: {Authorization: `Token ${ghToken}`}} : {})
          resp = await resp.json()
          componentsList = [...componentsList, ...resp.tree.map(item => `https://raw.githubusercontent.com/jstor-labs/juncture/${junctureVersionHash}/${componentsRoot}/${item.path}`)]
        }
      }
      return componentsList
    }
  
    function parseUrl(href) {
      const match = href.match(/^(https?):\/\/(([^:/?#]*)(?::([0-9]+))?)(\/?[^?#]*)(\?[^#]*|)(#.*|)$/)
      return (match && {protocol: match[1], host: match[2], hostname: match[3], origin: `${match[1]}://${match[2]}`,
              port: match[4], pathname: match[5] || '/', search: match[6], hash: match[7]}
      )
    }

    function parseQueryString(queryString) {
      queryString = queryString || window.location.search
      const dictionary = {}
      try {
        if (queryString.indexOf('?') === 0) queryString = queryString.substr(1)
        const parts = queryString.split('&')
        for (let i = 0; i < parts.length; i++) {
          const kvp = parts[i].split('=')
          if (kvp[0] !== '') {
            if (kvp.length === 2) {
              dictionary[kvp[0]] = decodeURIComponent(kvp[1]).replace(/\+/g, ' ')
            } else {
              dictionary[kvp[0]] = 'true'
            }
          }
        }
      } catch (err) { console.log(err) }
      return dictionary
    }

    function makeLink(href, rel) {
      let link = document.createElement('link')
      link.href = href
      link.rel = rel || 'stylesheet'
      return link
    }

    function makeScriptTag(src, crossorigin) {
      let el = document.createElement('script')
      el.src = src
      if (crossorigin) el.setAttribute('crossorigin', crossorigin)
      return el
    }

    function convertURL(current, path, pathIsDir) {
      let pathElems = []
      if (current.indexOf('http') === 0) {
        if (current.indexOf(window.location.origin) === 0) pathElems = current.split('/').slice(3)
        else return current
      } else if (current.indexOf('/') === 0) {
        pathElems = current.split('/').filter(elem => elem !== '')
      } else {
        pathElems = (path || window.location.pathname).split('/').filter(elem => elem !== '')
        if (!pathIsDir) pathElems = pathElems.slice(0, -1)
        pathElems = [...pathElems, ...current.split('/').filter(elem => elem !== '')]
      }
      if (isJuncture && pathElems.length >= 2) {
        if ((contentSource.repo !== 'juncture' || contentSource.acct !== 'jstor-labs') && pathElems[0] === contentSource.acct && pathElems[1] === contentSource.repo) pathElems = pathElems.slice(2)
      } else if (pathElems[0] === contentSource.repo) {
        pathElems = pathElems.slice(1)
      }
      // console.log(`assetsBaseUrl=${contentSource.assetsBaseUrl}`)
      converted = `${contentSource.assetsBaseUrl || contentSource.baseUrl}/${pathElems.join('/')}`
      // console.log(`convertURL: current=${current} converted=${converted} path=${path} pathIsDir=${pathIsDir} pathElems=${pathElems}`)
      return converted
    }

    async function sendEmail(options) {
      let resp = await fetch('https://visual-essays.app/send-email/', {
        method: 'POST', body: JSON.stringify(options),
        headers: {'Content-Type': 'application/json', Accept: 'application/json'},
      })
      return await resp.json()
    }
        
    // Google Analytics
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window ,document,'script','https://www.google-analytics.com/analytics.js','ga')
  </script>

</body>
</html>